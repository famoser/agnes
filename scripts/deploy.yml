input:
  PREVIOUS_RELEASE_TARGET: location # the previous release
  TARGET: location # the release target path. example: ~/www/app.mangel.io/production 
  REPOSITORY: repository # the github repository. example: mangelio/web
  RELEASE: release # the name of the release. example: v1.1
  SHARED: directory_list # list of directiories to be shared between deployments. example: var/persistent;var/transient

script:
  - export RELEASE_FOLDER=$TARGET/releases/$RELEASE
  - export SHARED_FOLDER=$TARGET/shared
  - export TEMP_FOLDER=$TARGET/tmp/$RELEASE
  - export ARTIFACT_NAME=release.zip
  - export ARTIFACT_URL=https://github.com/$REPOSITORY/releases/download/$RELEASE/$ARTIFACT_NAME
  - export ARTIFACT_DOWNLOAD_PATH=$TEMP_PATH/$ARTIFACT_NAME
  - IFS=';' read -r -a shared_dirs <<< "$SHARED"
  
  - mkdir -p RELEASE_FOLDER SHARED_FOLDER TEMP_FOLDER # create directory with parent directories, no error if already exists
  - curl $ARTIFACT_NAME --output $ARTIFACT_DOWNLOAD_PATH # download artifact
  - tar xzf $ARTIFACT_DOWNLOAD_PATH -C $RELEASE_FOLDER # extract artifact to release path
  - for shared_dir in "${shared_dirs[@]}"; do ln -s $RELEASE_FOLDER/$shared_dir $SHARED_FOLDER/$shared_dir; done # create shared folders
  - chmod -R 777 
    

download release artifact
unzip release artifact in folder /target/releases/$release_name or variations
create shared folders
set writable folders
set .env file
execute warmup
disable current release (or not?)
execute mirations
switch to new release
clean up old releases

-> need state file inside release folder
{ 
  "release": "v1.2", # release version
  "successful": true, # detect for automatic cleanup if enough releases available; detect errors with install & allow retry
  "online": [{
    "start": "2019-01-01T20:00:00"
    "end": null
  }]
}